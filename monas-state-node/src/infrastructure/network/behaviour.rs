//! NetworkBehaviour definition for the state node.
//!
//! Combines multiple libp2p protocols:
//! - Kademlia DHT for peer discovery and content routing
//! - Gossipsub for event propagation
//! - RequestResponse for direct peer communication
//! - mDNS for local peer discovery
//! - Identify for peer identification

use super::protocol::{ContentRequest, ContentResponse};
use libp2p::{
    gossipsub, identify, kad,
    request_response::{self, ProtocolSupport},
    swarm::NetworkBehaviour,
    StreamProtocol,
};
use std::time::Duration;

#[cfg(not(target_arch = "wasm32"))]
use libp2p::mdns;

/// Protocol name for content requests.
pub const CONTENT_PROTOCOL_NAME: &str = "/monas/content/1.0.0";

/// Combined network behaviour for the state node.
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "NodeBehaviourEvent")]
pub struct NodeBehaviour {
    /// Kademlia DHT for peer discovery and content routing.
    pub kademlia: kad::Behaviour<kad::store::MemoryStore>,
    /// Gossipsub for event propagation.
    pub gossipsub: gossipsub::Behaviour,
    /// RequestResponse for direct peer communication.
    pub request_response: request_response::cbor::Behaviour<ContentRequest, ContentResponse>,
    /// Identify for peer identification.
    pub identify: identify::Behaviour,
    /// mDNS for local peer discovery (native only).
    #[cfg(not(target_arch = "wasm32"))]
    pub mdns: mdns::tokio::Behaviour,
}

/// Events generated by the combined behaviour.
#[derive(Debug)]
pub enum NodeBehaviourEvent {
    Kademlia(kad::Event),
    Gossipsub(Box<gossipsub::Event>),
    RequestResponse(request_response::Event<ContentRequest, ContentResponse>),
    Identify(Box<identify::Event>),
    #[cfg(not(target_arch = "wasm32"))]
    Mdns(mdns::Event),
}

impl From<kad::Event> for NodeBehaviourEvent {
    fn from(event: kad::Event) -> Self {
        NodeBehaviourEvent::Kademlia(event)
    }
}

impl From<gossipsub::Event> for NodeBehaviourEvent {
    fn from(event: gossipsub::Event) -> Self {
        NodeBehaviourEvent::Gossipsub(Box::new(event))
    }
}

impl From<request_response::Event<ContentRequest, ContentResponse>> for NodeBehaviourEvent {
    fn from(event: request_response::Event<ContentRequest, ContentResponse>) -> Self {
        NodeBehaviourEvent::RequestResponse(event)
    }
}

impl From<identify::Event> for NodeBehaviourEvent {
    fn from(event: identify::Event) -> Self {
        NodeBehaviourEvent::Identify(Box::new(event))
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl From<mdns::Event> for NodeBehaviourEvent {
    fn from(event: mdns::Event) -> Self {
        NodeBehaviourEvent::Mdns(event)
    }
}

/// Configuration for creating a NodeBehaviour.
#[derive(Debug, Clone)]
pub struct BehaviourConfig {
    /// Protocol version string.
    pub protocol_version: String,
    /// Agent version string.
    pub agent_version: String,
}

impl Default for BehaviourConfig {
    fn default() -> Self {
        Self {
            protocol_version: "/monas/1.0.0".to_string(),
            agent_version: format!("monas-state-node/{}", env!("CARGO_PKG_VERSION")),
        }
    }
}

impl NodeBehaviour {
    /// Create a new NodeBehaviour with the given peer ID and configuration.
    #[cfg(not(target_arch = "wasm32"))]
    pub fn new(
        local_peer_id: libp2p::PeerId,
        keypair: &libp2p::identity::Keypair,
        config: BehaviourConfig,
    ) -> anyhow::Result<Self> {
        // Kademlia configuration
        let mut kad_config = kad::Config::new(StreamProtocol::new("/monas/kad/1.0.0"));
        kad_config.set_query_timeout(Duration::from_secs(60));
        let store = kad::store::MemoryStore::new(local_peer_id);
        let mut kademlia = kad::Behaviour::with_config(local_peer_id, store, kad_config);
        // Enable server mode so this node responds to Kademlia queries from other peers
        kademlia.set_mode(Some(kad::Mode::Server));

        // Gossipsub configuration
        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(1))
            .validation_mode(gossipsub::ValidationMode::Strict)
            .build()
            .map_err(|e| anyhow::anyhow!("Failed to create gossipsub config: {}", e))?;

        let gossipsub = gossipsub::Behaviour::new(
            gossipsub::MessageAuthenticity::Signed(keypair.clone()),
            gossipsub_config,
        )
        .map_err(|e| anyhow::anyhow!("Failed to create gossipsub behaviour: {}", e))?;

        // RequestResponse configuration using CBOR codec
        let request_response = request_response::cbor::Behaviour::new(
            [(
                StreamProtocol::new(CONTENT_PROTOCOL_NAME),
                ProtocolSupport::Full,
            )],
            request_response::Config::default(),
        );

        // Identify configuration
        let identify = identify::Behaviour::new(identify::Config::new(
            config.protocol_version,
            keypair.public(),
        ));

        // mDNS configuration
        let mdns = mdns::tokio::Behaviour::new(mdns::Config::default(), local_peer_id)?;

        Ok(Self {
            kademlia,
            gossipsub,
            request_response,
            identify,
            mdns,
        })
    }

    /// Create a new NodeBehaviour for WASM (without mDNS).
    #[cfg(target_arch = "wasm32")]
    pub fn new(
        local_peer_id: libp2p::PeerId,
        keypair: &libp2p::identity::Keypair,
        config: BehaviourConfig,
    ) -> anyhow::Result<Self> {
        // Kademlia configuration
        let mut kad_config = kad::Config::new(StreamProtocol::new("/monas/kad/1.0.0"));
        kad_config.set_query_timeout(Duration::from_secs(60));
        let store = kad::store::MemoryStore::new(local_peer_id);
        let mut kademlia = kad::Behaviour::with_config(local_peer_id, store, kad_config);
        // Enable server mode so this node responds to Kademlia queries from other peers
        kademlia.set_mode(Some(kad::Mode::Server));

        // Gossipsub configuration
        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(1))
            .validation_mode(gossipsub::ValidationMode::Strict)
            .build()
            .map_err(|e| anyhow::anyhow!("Failed to create gossipsub config: {}", e))?;

        let gossipsub = gossipsub::Behaviour::new(
            gossipsub::MessageAuthenticity::Signed(keypair.clone()),
            gossipsub_config,
        )
        .map_err(|e| anyhow::anyhow!("Failed to create gossipsub behaviour: {}", e))?;

        // RequestResponse configuration using CBOR codec
        let request_response = request_response::cbor::Behaviour::new(
            [(
                StreamProtocol::new(CONTENT_PROTOCOL_NAME),
                ProtocolSupport::Full,
            )],
            request_response::Config::default(),
        );

        // Identify configuration
        let identify = identify::Behaviour::new(identify::Config::new(
            config.protocol_version,
            keypair.public(),
        ));

        Ok(Self {
            kademlia,
            gossipsub,
            request_response,
            identify,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use libp2p::identity::Keypair;

    #[test]
    fn test_content_protocol_name() {
        assert_eq!(CONTENT_PROTOCOL_NAME, "/monas/content/1.0.0");
    }

    #[test]
    fn test_behaviour_config_default() {
        let config = BehaviourConfig::default();

        assert_eq!(config.protocol_version, "/monas/1.0.0");
        assert!(config.agent_version.starts_with("monas-state-node/"));
    }

    #[test]
    fn test_behaviour_config_clone() {
        let config = BehaviourConfig {
            protocol_version: "/custom/1.0.0".to_string(),
            agent_version: "custom-agent/1.0.0".to_string(),
        };

        let cloned = config.clone();

        assert_eq!(cloned.protocol_version, "/custom/1.0.0");
        assert_eq!(cloned.agent_version, "custom-agent/1.0.0");
    }

    #[test]
    fn test_behaviour_config_debug() {
        let config = BehaviourConfig::default();
        let debug_str = format!("{:?}", config);

        assert!(debug_str.contains("BehaviourConfig"));
        assert!(debug_str.contains("protocol_version"));
        assert!(debug_str.contains("agent_version"));
    }

    #[test]
    fn test_node_behaviour_event_debug() {
        // Test that NodeBehaviourEvent implements Debug
        // We can't easily create kad::Event, gossipsub::Event, etc. in tests,
        // but we can verify the enum variants exist and the type is Debug
        fn assert_debug<T: std::fmt::Debug>() {}
        assert_debug::<NodeBehaviourEvent>();
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[test]
    fn test_node_behaviour_creation() {
        let keypair = Keypair::generate_ed25519();
        let local_peer_id = keypair.public().to_peer_id();
        let config = BehaviourConfig::default();

        let result = NodeBehaviour::new(local_peer_id, &keypair, config);

        assert!(result.is_ok());
        let behaviour = result.unwrap();

        // Verify components are accessible
        let _ = &behaviour.kademlia;
        let _ = &behaviour.gossipsub;
        let _ = &behaviour.request_response;
        let _ = &behaviour.identify;
        let _ = &behaviour.mdns;
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[test]
    fn test_node_behaviour_with_custom_config() {
        let keypair = Keypair::generate_ed25519();
        let local_peer_id = keypair.public().to_peer_id();
        let config = BehaviourConfig {
            protocol_version: "/test/1.0.0".to_string(),
            agent_version: "test-agent/0.1.0".to_string(),
        };

        let result = NodeBehaviour::new(local_peer_id, &keypair, config);

        assert!(result.is_ok());
    }

    // Test From implementations for NodeBehaviourEvent
    // These test the event conversion traits

    #[test]
    fn test_from_kad_event() {
        // Create a simple Kademlia event that we can construct
        // kad::Event has several variants; RoutingUpdated is one that's relatively easy to reason about
        // However, creating actual kad::Event instances requires complex setup,
        // so we verify the From implementation exists by type checking
        fn assert_from_impl<T, U>()
        where
            U: From<T>,
        {
        }
        assert_from_impl::<kad::Event, NodeBehaviourEvent>();
    }

    #[test]
    fn test_from_gossipsub_event() {
        fn assert_from_impl<T, U>()
        where
            U: From<T>,
        {
        }
        assert_from_impl::<gossipsub::Event, NodeBehaviourEvent>();
    }

    #[test]
    fn test_from_request_response_event() {
        fn assert_from_impl<T, U>()
        where
            U: From<T>,
        {
        }
        assert_from_impl::<
            request_response::Event<ContentRequest, ContentResponse>,
            NodeBehaviourEvent,
        >();
    }

    #[test]
    fn test_from_identify_event() {
        fn assert_from_impl<T, U>()
        where
            U: From<T>,
        {
        }
        assert_from_impl::<identify::Event, NodeBehaviourEvent>();
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[test]
    fn test_from_mdns_event() {
        fn assert_from_impl<T, U>()
        where
            U: From<T>,
        {
        }
        assert_from_impl::<mdns::Event, NodeBehaviourEvent>();
    }

    #[test]
    fn test_agent_version_contains_package_version() {
        let config = BehaviourConfig::default();
        let pkg_version = env!("CARGO_PKG_VERSION");

        assert!(
            config.agent_version.contains(pkg_version),
            "Agent version '{}' should contain package version '{}'",
            config.agent_version,
            pkg_version
        );
    }
}
