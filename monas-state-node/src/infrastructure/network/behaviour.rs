//! NetworkBehaviour definition for the state node.
//!
//! Combines multiple libp2p protocols:
//! - Kademlia DHT for peer discovery and content routing
//! - Gossipsub for event propagation
//! - RequestResponse for direct peer communication
//! - mDNS for local peer discovery
//! - Identify for peer identification

use super::protocol::{ContentRequest, ContentResponse};
use libp2p::{
    gossipsub, identify, kad,
    request_response::{self, ProtocolSupport},
    swarm::NetworkBehaviour,
    StreamProtocol,
};
use std::time::Duration;

#[cfg(not(target_arch = "wasm32"))]
use libp2p::mdns;

/// Protocol name for content requests.
pub const CONTENT_PROTOCOL_NAME: &str = "/monas/content/1.0.0";

/// Combined network behaviour for the state node.
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "NodeBehaviourEvent")]
pub struct NodeBehaviour {
    /// Kademlia DHT for peer discovery and content routing.
    pub kademlia: kad::Behaviour<kad::store::MemoryStore>,
    /// Gossipsub for event propagation.
    pub gossipsub: gossipsub::Behaviour,
    /// RequestResponse for direct peer communication.
    pub request_response: request_response::cbor::Behaviour<ContentRequest, ContentResponse>,
    /// Identify for peer identification.
    pub identify: identify::Behaviour,
    /// mDNS for local peer discovery (native only).
    #[cfg(not(target_arch = "wasm32"))]
    pub mdns: mdns::tokio::Behaviour,
}

/// Events generated by the combined behaviour.
#[derive(Debug)]
pub enum NodeBehaviourEvent {
    Kademlia(kad::Event),
    Gossipsub(gossipsub::Event),
    RequestResponse(request_response::Event<ContentRequest, ContentResponse>),
    Identify(identify::Event),
    #[cfg(not(target_arch = "wasm32"))]
    Mdns(mdns::Event),
}

impl From<kad::Event> for NodeBehaviourEvent {
    fn from(event: kad::Event) -> Self {
        NodeBehaviourEvent::Kademlia(event)
    }
}

impl From<gossipsub::Event> for NodeBehaviourEvent {
    fn from(event: gossipsub::Event) -> Self {
        NodeBehaviourEvent::Gossipsub(event)
    }
}

impl From<request_response::Event<ContentRequest, ContentResponse>> for NodeBehaviourEvent {
    fn from(event: request_response::Event<ContentRequest, ContentResponse>) -> Self {
        NodeBehaviourEvent::RequestResponse(event)
    }
}

impl From<identify::Event> for NodeBehaviourEvent {
    fn from(event: identify::Event) -> Self {
        NodeBehaviourEvent::Identify(event)
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl From<mdns::Event> for NodeBehaviourEvent {
    fn from(event: mdns::Event) -> Self {
        NodeBehaviourEvent::Mdns(event)
    }
}

/// Configuration for creating a NodeBehaviour.
#[derive(Debug, Clone)]
pub struct BehaviourConfig {
    /// Protocol version string.
    pub protocol_version: String,
    /// Agent version string.
    pub agent_version: String,
}

impl Default for BehaviourConfig {
    fn default() -> Self {
        Self {
            protocol_version: "/monas/1.0.0".to_string(),
            agent_version: format!("monas-state-node/{}", env!("CARGO_PKG_VERSION")),
        }
    }
}

impl NodeBehaviour {
    /// Create a new NodeBehaviour with the given peer ID and configuration.
    #[cfg(not(target_arch = "wasm32"))]
    pub fn new(
        local_peer_id: libp2p::PeerId,
        keypair: &libp2p::identity::Keypair,
        config: BehaviourConfig,
    ) -> anyhow::Result<Self> {
        // Kademlia configuration
        let mut kad_config = kad::Config::new(StreamProtocol::new("/monas/kad/1.0.0"));
        kad_config.set_query_timeout(Duration::from_secs(60));
        let store = kad::store::MemoryStore::new(local_peer_id);
        let mut kademlia = kad::Behaviour::with_config(local_peer_id, store, kad_config);
        // Enable server mode so this node responds to Kademlia queries from other peers
        kademlia.set_mode(Some(kad::Mode::Server));

        // Gossipsub configuration
        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(1))
            .validation_mode(gossipsub::ValidationMode::Strict)
            .build()
            .map_err(|e| anyhow::anyhow!("Failed to create gossipsub config: {}", e))?;

        let gossipsub = gossipsub::Behaviour::new(
            gossipsub::MessageAuthenticity::Signed(keypair.clone()),
            gossipsub_config,
        )
        .map_err(|e| anyhow::anyhow!("Failed to create gossipsub behaviour: {}", e))?;

        // RequestResponse configuration using CBOR codec
        let request_response = request_response::cbor::Behaviour::new(
            [(
                StreamProtocol::new(CONTENT_PROTOCOL_NAME),
                ProtocolSupport::Full,
            )],
            request_response::Config::default(),
        );

        // Identify configuration
        let identify = identify::Behaviour::new(identify::Config::new(
            config.protocol_version,
            keypair.public(),
        ));

        // mDNS configuration
        let mdns = mdns::tokio::Behaviour::new(mdns::Config::default(), local_peer_id)?;

        Ok(Self {
            kademlia,
            gossipsub,
            request_response,
            identify,
            mdns,
        })
    }

    /// Create a new NodeBehaviour for WASM (without mDNS).
    #[cfg(target_arch = "wasm32")]
    pub fn new(
        local_peer_id: libp2p::PeerId,
        keypair: &libp2p::identity::Keypair,
        config: BehaviourConfig,
    ) -> anyhow::Result<Self> {
        // Kademlia configuration
        let mut kad_config = kad::Config::new(StreamProtocol::new("/monas/kad/1.0.0"));
        kad_config.set_query_timeout(Duration::from_secs(60));
        let store = kad::store::MemoryStore::new(local_peer_id);
        let mut kademlia = kad::Behaviour::with_config(local_peer_id, store, kad_config);
        // Enable server mode so this node responds to Kademlia queries from other peers
        kademlia.set_mode(Some(kad::Mode::Server));

        // Gossipsub configuration
        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(1))
            .validation_mode(gossipsub::ValidationMode::Strict)
            .build()
            .map_err(|e| anyhow::anyhow!("Failed to create gossipsub config: {}", e))?;

        let gossipsub = gossipsub::Behaviour::new(
            gossipsub::MessageAuthenticity::Signed(keypair.clone()),
            gossipsub_config,
        )
        .map_err(|e| anyhow::anyhow!("Failed to create gossipsub behaviour: {}", e))?;

        // RequestResponse configuration using CBOR codec
        let request_response = request_response::cbor::Behaviour::new(
            [(
                StreamProtocol::new(CONTENT_PROTOCOL_NAME),
                ProtocolSupport::Full,
            )],
            request_response::Config::default(),
        );

        // Identify configuration
        let identify = identify::Behaviour::new(identify::Config::new(
            config.protocol_version,
            keypair.public(),
        ));

        Ok(Self {
            kademlia,
            gossipsub,
            request_response,
            identify,
        })
    }
}

